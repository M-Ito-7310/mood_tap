# Database Schema

## „Éá„Éº„Çø„Éô„Éº„ÇπÊ¶ÇË¶Å

MoodTap„ÅØ„ÄÅNeon PostgreSQL„Çí„Éá„Éº„Çø„Éô„Éº„Çπ„Å®„Åó„Å¶‰ΩøÁî®„Åó„Åæ„Åô„ÄÇ„É¶„Éº„Ç∂„Éº„ÅÆÊ∞óÂàÜË®òÈå≤„ÇíÊ∞∏Á∂öÂåñ„Åó„ÄÅÁµ±Ë®àÂàÜÊûê„ÇÑÈï∑ÊúüÁöÑ„Å™„Éà„É¨„É≥„ÉâÊääÊè°„ÇíÂèØËÉΩ„Å´„Åó„Åæ„Åô„ÄÇ

### ‰ΩøÁî®ÊäÄË°ì
- **Database**: Neon PostgreSQL (Serverless)
- **ORM**: Drizzle ORM
- **Migration**: Drizzle Kit

---

## Phase 1: MVPÊÆµÈöé„ÅÆ„Éá„Éº„ÇøÁÆ°ÁêÜ

### LocalStorage(„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Çµ„Ç§„Éâ)

MVP Phase 1„Åß„ÅØ„ÄÅ**Ë™çË®ºÊ©üËÉΩ„Å™„Åó**„ÅÆ„Åü„ÇÅ„ÄÅ„Éá„Éº„Çø„ÅØ„Éñ„É©„Ç¶„Ç∂„ÅÆLocalStorage„Å´‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ

#### „Éá„Éº„ÇøÊßãÈÄ†

```typescript
// LocalStorage„Ç≠„Éº
const STORAGE_KEY = 'moodtap_entries';

// „Éá„Éº„ÇøÂûãÂÆöÁæ©
interface MoodEntry {
  id: string;                    // UUID
  date: string;                  // ISO 8601ÂΩ¢Âºè (‰æã: "2025-10-23")
  moodScore: 1 | 2 | 3 | 4 | 5;  // Ê∞óÂàÜ„Çπ„Ç≥„Ç¢
  moodLabel: 'very_bad' | 'bad' | 'neutral' | 'good' | 'very_good'; // „É©„Éô„É´
  note?: string;                 // „Ç™„Éó„Ç∑„Éß„É≥„É°„É¢(ÊúÄÂ§ß100ÊñáÂ≠ó)
  createdAt: string;             // Ë®òÈå≤ÊôÇÂàª(ISO 8601)
  updatedAt?: string;            // Êõ¥Êñ∞ÊôÇÂàª(„Ç™„Éó„Ç∑„Éß„É≥)
}

// LocalStorage„Å´‰øùÂ≠ò„Åï„Çå„Çã„Éá„Éº„Çø‰æã
{
  "moodtap_entries": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "date": "2025-10-23",
      "moodScore": 4,
      "moodLabel": "good",
      "note": "‰ªäÊó•„ÅØ„Éó„É¨„Çº„É≥„ÅåÊàêÂäü„Åó„Åü!",
      "createdAt": "2025-10-23T09:30:00.000Z"
    },
    {
      "id": "550e8400-e29b-41d4-a716-446655440001",
      "date": "2025-10-22",
      "moodScore": 3,
      "moodLabel": "neutral",
      "createdAt": "2025-10-22T22:15:00.000Z"
    }
  ]
}
```

#### LocalStorageÊìç‰ΩúÈñ¢Êï∞

```typescript
// lib/localStorage.ts

export function saveMoodEntry(entry: MoodEntry): void {
  const entries = getMoodEntries();
  entries.push(entry);
  localStorage.setItem(STORAGE_KEY, JSON.stringify(entries));
}

export function getMoodEntries(): MoodEntry[] {
  const data = localStorage.getItem(STORAGE_KEY);
  if (!data) return [];
  try {
    return JSON.parse(data);
  } catch (error) {
    console.error('LocalStorage parse error:', error);
    return [];
  }
}

export function getMoodEntryByDate(date: string): MoodEntry | null {
  const entries = getMoodEntries();
  return entries.find(entry => entry.date === date) || null;
}

export function updateMoodEntry(id: string, updates: Partial<MoodEntry>): void {
  const entries = getMoodEntries();
  const index = entries.findIndex(entry => entry.id === id);
  if (index !== -1) {
    entries[index] = { ...entries[index], ...updates, updatedAt: new Date().toISOString() };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(entries));
  }
}

export function deleteMoodEntry(id: string): void {
  const entries = getMoodEntries();
  const filtered = entries.filter(entry => entry.id !== id);
  localStorage.setItem(STORAGE_KEY, JSON.stringify(filtered));
}
```

---

## Phase 2: PostgreSQLÁßªË°åÂæå„ÅÆ„Çπ„Ç≠„Éº„ÉûË®≠Ë®à

### „ÉÜ„Éº„Éñ„É´Ë®≠Ë®à

Phase 2„ÅßË™çË®ºÊ©üËÉΩ„Å®„Éá„Éº„Çø„Éô„Éº„Çπ„ÇíÂ∞éÂÖ•„Åô„ÇãÈöõ„ÅÆ„Çπ„Ç≠„Éº„ÉûË®≠Ë®à„Åß„Åô„ÄÇ

---

### 1. users „ÉÜ„Éº„Éñ„É´

„É¶„Éº„Ç∂„Éº„ÅÆÂü∫Êú¨ÊÉÖÂ†±„Çí‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ

#### „Çπ„Ç≠„Éº„ÉûÂÆöÁæ©

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(100),
  avatar_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_created_at ON users(created_at DESC);
```

#### „Ç´„É©„É†Ë©≥Á¥∞

| „Ç´„É©„É†Âêç | Âûã | NULL | „Éá„Éï„Ç©„É´„Éà | Ë™¨Êòé |
|---------|-----|------|-----------|------|
| id | UUID | NO | gen_random_uuid() | „É¶„Éº„Ç∂„Éº‰∏ÄÊÑèË≠òÂà•Â≠ê |
| email | VARCHAR(255) | NO | - | „É°„Éº„É´„Ç¢„Éâ„É¨„Çπ(NextAuthË™çË®ºÁî®) |
| name | VARCHAR(100) | YES | NULL | „É¶„Éº„Ç∂„ÉºÂêç |
| avatar_url | TEXT | YES | NULL | „Éó„É≠„Éï„Ç£„Éº„É´ÁîªÂÉèURL |
| created_at | TIMESTAMP WITH TIME ZONE | NO | NOW() | ‰ΩúÊàêÊó•ÊôÇ |
| updated_at | TIMESTAMP WITH TIME ZONE | NO | NOW() | Êõ¥Êñ∞Êó•ÊôÇ |

---

### 2. mood_entries „ÉÜ„Éº„Éñ„É´

Ê∞óÂàÜË®òÈå≤„ÅÆÊú¨‰Ωì„Éá„Éº„Çø„Çí‰øùÂ≠ò„Åó„Åæ„Åô„ÄÇ

#### „Çπ„Ç≠„Éº„ÉûÂÆöÁæ©

```sql
CREATE TABLE mood_entries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  mood_score SMALLINT NOT NULL CHECK (mood_score BETWEEN 1 AND 5),
  mood_label VARCHAR(20) NOT NULL,
  note TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, date) -- 1Êó•1Âõû„ÅÆË®òÈå≤Âà∂Á¥Ñ
);

-- „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
CREATE INDEX idx_mood_entries_user_id ON mood_entries(user_id);
CREATE INDEX idx_mood_entries_date ON mood_entries(date DESC);
CREATE INDEX idx_mood_entries_user_date ON mood_entries(user_id, date DESC);
CREATE INDEX idx_mood_entries_mood_score ON mood_entries(mood_score);
```

#### „Ç´„É©„É†Ë©≥Á¥∞

| „Ç´„É©„É†Âêç | Âûã | NULL | „Éá„Éï„Ç©„É´„Éà | Ë™¨Êòé |
|---------|-----|------|-----------|------|
| id | UUID | NO | gen_random_uuid() | Ë®òÈå≤‰∏ÄÊÑèË≠òÂà•Â≠ê |
| user_id | UUID | NO | - | „É¶„Éº„Ç∂„ÉºID(Â§ñÈÉ®„Ç≠„Éº) |
| date | DATE | NO | - | Ë®òÈå≤Êó•‰ªò(YYYY-MM-DD) |
| mood_score | SMALLINT | NO | - | Ê∞óÂàÜ„Çπ„Ç≥„Ç¢(1-5) |
| mood_label | VARCHAR(20) | NO | - | Ê∞óÂàÜ„É©„Éô„É´ |
| note | TEXT | YES | NULL | „Ç™„Éó„Ç∑„Éß„É≥„É°„É¢(100ÊñáÂ≠ó‰ª•ÂÜÖ) |
| created_at | TIMESTAMP WITH TIME ZONE | NO | NOW() | ‰ΩúÊàêÊó•ÊôÇ |
| updated_at | TIMESTAMP WITH TIME ZONE | NO | NOW() | Êõ¥Êñ∞Êó•ÊôÇ |

#### Âà∂Á¥Ñ
- **UNIQUE(user_id, date)**: 1„É¶„Éº„Ç∂„Éº1Êó•1Âõû„ÅÆË®òÈå≤„ÅÆ„Åø
- **CHECK(mood_score BETWEEN 1 AND 5)**: „Çπ„Ç≥„Ç¢„ÅØ1-5„ÅÆÁØÑÂõ≤

---

### 3. mood_labels „ÉÜ„Éº„Éñ„É´(„Éû„Çπ„Çø„Éº„Éá„Éº„Çø)

Ê∞óÂàÜ„É©„Éô„É´„ÅÆ„Éû„Çπ„Çø„Éº„Éá„Éº„Çø„Åß„Åô„ÄÇ

#### „Çπ„Ç≠„Éº„ÉûÂÆöÁæ©

```sql
CREATE TABLE mood_labels (
  id SERIAL PRIMARY KEY,
  score SMALLINT UNIQUE NOT NULL,
  label VARCHAR(20) UNIQUE NOT NULL,
  emoji VARCHAR(10) NOT NULL,
  color VARCHAR(20) NOT NULL,
  description VARCHAR(100)
);

-- ÂàùÊúü„Éá„Éº„ÇøÊåøÂÖ•
INSERT INTO mood_labels (score, label, emoji, color, description) VALUES
  (5, 'very_good', 'üòÑ', '#3B82F6', '„Å®„Å¶„ÇÇËâØ„ÅÑ'),
  (4, 'good', 'üòä', '#60A5FA', 'ËâØ„ÅÑ'),
  (3, 'neutral', 'üòê', '#9CA3AF', 'ÊôÆÈÄö'),
  (2, 'bad', 'üòî', '#FB923C', 'ÊÇ™„ÅÑ'),
  (1, 'very_bad', 'üò¢', '#EF4444', '„Å®„Å¶„ÇÇÊÇ™„ÅÑ');
```

#### „Ç´„É©„É†Ë©≥Á¥∞

| „Ç´„É©„É†Âêç | Âûã | NULL | „Éá„Éï„Ç©„É´„Éà | Ë™¨Êòé |
|---------|-----|------|-----------|------|
| id | SERIAL | NO | AUTO_INCREMENT | „Éû„Çπ„Çø„ÉºID |
| score | SMALLINT | NO | - | Ê∞óÂàÜ„Çπ„Ç≥„Ç¢(1-5) |
| label | VARCHAR(20) | NO | - | Ê∞óÂàÜ„É©„Éô„É´(Ëã±Ë™û) |
| emoji | VARCHAR(10) | NO | - | ÁµµÊñáÂ≠ó |
| color | VARCHAR(20) | NO | - | „Éí„Éº„Éà„Éû„ÉÉ„ÉóËâ≤ |
| description | VARCHAR(100) | YES | NULL | Êó•Êú¨Ë™ûË™¨Êòé |

---

## Drizzle ORM „Çπ„Ç≠„Éº„ÉûÂÆöÁæ©

### lib/db/schema.ts

```typescript
import { pgTable, uuid, varchar, text, timestamp, date, smallint, serial } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

// users„ÉÜ„Éº„Éñ„É´
export const users = pgTable('users', {
  id: uuid('id').defaultRandom().primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  name: varchar('name', { length: 100 }),
  avatarUrl: text('avatar_url'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
});

// mood_entries„ÉÜ„Éº„Éñ„É´
export const moodEntries = pgTable('mood_entries', {
  id: uuid('id').defaultRandom().primaryKey(),
  userId: uuid('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  date: date('date').notNull(),
  moodScore: smallint('mood_score').notNull(),
  moodLabel: varchar('mood_label', { length: 20 }).notNull(),
  note: text('note'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
});

// mood_labels„ÉÜ„Éº„Éñ„É´
export const moodLabels = pgTable('mood_labels', {
  id: serial('id').primaryKey(),
  score: smallint('score').notNull().unique(),
  label: varchar('label', { length: 20 }).notNull().unique(),
  emoji: varchar('emoji', { length: 10 }).notNull(),
  color: varchar('color', { length: 20 }).notNull(),
  description: varchar('description', { length: 100 }),
});

// „É™„É¨„Éº„Ç∑„Éß„É≥ÂÆöÁæ©
export const usersRelations = relations(users, ({ many }) => ({
  moodEntries: many(moodEntries),
}));

export const moodEntriesRelations = relations(moodEntries, ({ one }) => ({
  user: one(users, {
    fields: [moodEntries.userId],
    references: [users.id],
  }),
}));

// Âûã„Ç®„ÇØ„Çπ„Éù„Éº„Éà
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
export type MoodEntry = typeof moodEntries.$inferSelect;
export type NewMoodEntry = typeof moodEntries.$inferInsert;
export type MoodLabel = typeof moodLabels.$inferSelect;
```

---

## „Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂öË®≠ÂÆö

### Áí∞Â¢ÉÂ§âÊï∞ (.env.local)

```env
# Neon PostgreSQL Connection String
DATABASE_URL="postgresql://username:password@ep-xxxxx.us-east-2.aws.neon.tech/moodtap?sslmode=require"
```

### lib/db/index.ts

```typescript
import { neon } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';
import * as schema from './schema';

// Neon SQL Client
const sql = neon(process.env.DATABASE_URL!);

// Drizzle ORM Instance
export const db = drizzle(sql, { schema });
```

---

## „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥

### drizzle.config.ts

```typescript
import type { Config } from 'drizzle-kit';
import { config } from 'dotenv';

// .env.local „ÇíË™≠„ÅøËæº„Åø
config({ path: '.env.local' });

export default {
  schema: './src/lib/db/schema.ts',
  out: './drizzle',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
} satisfies Config;
```

### „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„Ç≥„Éû„É≥„Éâ

```bash
# „Çπ„Ç≠„Éº„Éû„Åã„Çâ„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„Éï„Ç°„Ç§„É´ÁîüÊàê
npm run db:generate

# „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥ÂÆüË°å
npm run db:push

# Drizzle StudioËµ∑Âãï(GUIÁÆ°ÁêÜ„ÉÑ„Éº„É´)
npm run db:studio
```

### package.json scripts

```json
{
  "scripts": {
    "db:generate": "drizzle-kit generate:pg",
    "db:push": "drizzle-kit push:pg",
    "db:studio": "drizzle-kit studio"
  }
}
```

---

## CRUDÊìç‰Ωú‰æã

### lib/db/queries.ts

```typescript
import { db } from './index';
import { moodEntries, users } from './schema';
import { eq, desc, and, gte, lte } from 'drizzle-orm';

// Ê∞óÂàÜË®òÈå≤„ÅÆ‰ΩúÊàê
export async function createMoodEntry(data: {
  userId: string;
  date: string; // YYYY-MM-DD
  moodScore: number;
  moodLabel: string;
  note?: string;
}) {
  const result = await db
    .insert(moodEntries)
    .values({
      userId: data.userId,
      date: data.date,
      moodScore: data.moodScore,
      moodLabel: data.moodLabel,
      note: data.note,
    })
    .onConflictDoUpdate({
      target: [moodEntries.userId, moodEntries.date],
      set: {
        moodScore: data.moodScore,
        moodLabel: data.moodLabel,
        note: data.note,
        updatedAt: new Date(),
      },
    })
    .returning();

  return result[0];
}

// „É¶„Éº„Ç∂„Éº„ÅÆÊ∞óÂàÜË®òÈå≤‰∏ÄË¶ßÂèñÂæó(ÊúÄÊñ∞30Êó•)
export async function getMoodEntriesByUser(userId: string, limit = 30) {
  return await db
    .select()
    .from(moodEntries)
    .where(eq(moodEntries.userId, userId))
    .orderBy(desc(moodEntries.date))
    .limit(limit);
}

// ÁâπÂÆöÊó•„ÅÆÊ∞óÂàÜË®òÈå≤ÂèñÂæó
export async function getMoodEntryByDate(userId: string, date: string) {
  const result = await db
    .select()
    .from(moodEntries)
    .where(and(eq(moodEntries.userId, userId), eq(moodEntries.date, date)))
    .limit(1);

  return result[0] || null;
}

// ÊúüÈñìÊåáÂÆö„Åß„ÅÆÊ∞óÂàÜË®òÈå≤ÂèñÂæó
export async function getMoodEntriesByDateRange(
  userId: string,
  startDate: string,
  endDate: string
) {
  return await db
    .select()
    .from(moodEntries)
    .where(
      and(
        eq(moodEntries.userId, userId),
        gte(moodEntries.date, startDate),
        lte(moodEntries.date, endDate)
      )
    )
    .orderBy(desc(moodEntries.date));
}

// Ê∞óÂàÜË®òÈå≤„ÅÆÂâäÈô§
export async function deleteMoodEntry(id: string) {
  const result = await db
    .delete(moodEntries)
    .where(eq(moodEntries.id, id))
    .returning();

  return result[0] || null;
}
```

---

## API RouteÂÆüË£Ö‰æã

### app/api/mood-entries/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createMoodEntry, getMoodEntriesByUser } from '@/lib/db/queries';
import { getServerSession } from 'next-auth';

// GET /api/mood-entries - Ê∞óÂàÜË®òÈå≤‰∏ÄË¶ßÂèñÂæó
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const entries = await getMoodEntriesByUser(session.user.id);
    return NextResponse.json({ entries });
  } catch (error) {
    console.error('Failed to fetch mood entries:', error);
    return NextResponse.json(
      { error: 'Failed to fetch mood entries' },
      { status: 500 }
    );
  }
}

// POST /api/mood-entries - Ê∞óÂàÜË®òÈå≤„ÅÆ‰ΩúÊàê
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession();
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { date, moodScore, moodLabel, note } = body;

    // „Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    if (!date || !moodScore || !moodLabel) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    if (moodScore < 1 || moodScore > 5) {
      return NextResponse.json(
        { error: 'Invalid mood score' },
        { status: 400 }
      );
    }

    const entry = await createMoodEntry({
      userId: session.user.id,
      date,
      moodScore,
      moodLabel,
      note,
    });

    return NextResponse.json({ entry }, { status: 201 });
  } catch (error) {
    console.error('Failed to create mood entry:', error);
    return NextResponse.json(
      { error: 'Failed to create mood entry' },
      { status: 500 }
    );
  }
}
```

---

## „Éá„Éº„Çø„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥Êà¶Áï•

### Phase 1 ‚Üí Phase 2 ÁßªË°å

LocalStorage„Åã„ÇâPostgreSQL„Å∏„ÅÆ„Éá„Éº„ÇøÁßªË°åÊ©üËÉΩ„ÇíÂÆüË£Ö„Åó„Åæ„Åô„ÄÇ

```typescript
// lib/migration.ts

export async function migrateLocalStorageToDatabase(userId: string) {
  const localEntries = getMoodEntries(); // LocalStorage„Åã„ÇâÂèñÂæó

  for (const entry of localEntries) {
    await createMoodEntry({
      userId,
      date: entry.date,
      moodScore: entry.moodScore,
      moodLabel: entry.moodLabel,
      note: entry.note,
    });
  }

  // ÁßªË°åÂÆå‰∫ÜÂæå„ÄÅLocalStorage„ÇØ„É™„Ç¢
  localStorage.removeItem(STORAGE_KEY);
}
```

---

## „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ

### „Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÊúÄÈÅ©Âåñ

```sql
-- Ë§áÂêà„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ(user_id + date)
CREATE INDEX idx_mood_entries_user_date ON mood_entries(user_id, date DESC);

-- ÈÉ®ÂàÜ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ(ÊúÄÊñ∞30Êó•„ÅÆ„Åø)
CREATE INDEX idx_mood_entries_recent
  ON mood_entries(user_id, date DESC)
  WHERE date >= CURRENT_DATE - INTERVAL '30 days';
```

### Ëá™ÂãïÊõ¥Êñ∞„Çø„Ç§„É†„Çπ„Çø„É≥„Éó„Éà„É™„Ç¨„Éº

```sql
-- updated_atËá™ÂãïÊõ¥Êñ∞„Éà„É™„Ç¨„Éº
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_mood_entries_updated_at
  BEFORE UPDATE ON mood_entries
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

---

## „Åæ„Å®„ÇÅ

MoodTap„ÅÆ„Éá„Éº„Çø„Éô„Éº„ÇπË®≠Ë®à„ÅØ„ÄÅ‰ª•‰∏ã„ÅÆÊÆµÈöéÁöÑ„Ç¢„Éó„É≠„Éº„ÉÅ„ÇíÊé°Áî®„Åó„Åæ„Åô:

1. **Phase 1 (MVP)**: LocalStorage(„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Çµ„Ç§„Éâ)
2. **Phase 2**: Neon PostgreSQL + Drizzle ORMÁßªË°å
3. **Phase 3‰ª•Èôç**: Áµ±Ë®à„ÉÜ„Éº„Éñ„É´„ÄÅ„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊ©üËÉΩ„ÅÆÊã°Âºµ

„Ç∑„É≥„Éó„É´„Å™„Çπ„Ç≠„Éº„ÉûË®≠Ë®à„Å´„Çà„Çä„ÄÅÈ´òÈÄü„Å™ÈñãÁô∫„Å®Â∞ÜÊù•ÁöÑ„Å™Êã°ÂºµÊÄß„Çí‰∏°Á´ã„Åó„Åæ„Åô„ÄÇ

---

**„Éâ„Ç≠„É•„É°„É≥„Éà‰ΩúÊàêËÄÖ**: AI Agent (Claude)
**‰ΩúÊàêÊó•**: 2025Âπ¥10Êúà23Êó•
**„Éê„Éº„Ç∏„Éß„É≥**: 1.0
